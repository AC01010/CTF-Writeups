**Seekrypt (crypto/23 solves)**

The output of the program is the flag, encrypted bit by bit, a portion of one of the primes *alpha*, as well as *n*, which is *alpha* x *beta*. The first step is to recover *alpha* & *beta* using the Lenstra–Lenstra–Lovász lattice basis reduction algorithm, which is implemented with Sage's *small_roots()* function.

```python
p = 136437248584749771882310599149278388531535057166399265926387706469408766646754256272579824944594286947565201090386154252642859489386692473805411897253949013507330688499956189228793511815053892879974238599863038816313198964134947169977378713887483007849103288310288698573564963610808423262228756458677190730145
n = 15208002172852064705513549049156125156229213752159018163825621612365155017442357321243997240694068589814280403280924059115680689958405528673283969584726875025903837971544565855345730100919461985993701827484692130096087415066915297046298354141978649627535608324891962634115164448150854962245168416609362554295547467846154568712738134639516660184864893586000423886731114509172379025554849606702807764604046562890333894888196970691461892191718079065215120535321387122435702257687877333759869565354852332910433540118176537491958544695956496612702255403127864825597702515541366203734967406176296928067151309367243599261047
pbot = (p%2^496)
ptop = p - (p%2^728)
a = (pbot+ptop)
PR.<x> = PolynomialRing(Zmod(n))
f = (x*2^496 + a).monic()
sol = f.small_roots(X=2^232, beta=0.3)[0]
print (ptop + sol*2^496 + pbot)
```

After recovering p and q, I just have to test each number in the output file to check if it is a quadratic residue mod n - this task is trivial, as we now know the values of p and q.

I took a script online to test each number to check if it was a quadratic residue mod n, and modified the script to manually give it the factors.

Flag: flag{y0u_f0und_m0re_th4n_s3cr3ts.....th3_fl4g_1ts3lf!!!!}
